"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const Credstash = require('aws-credstash');
const bluebird_1 = require("bluebird");
const utils_1 = require("./utils");
exports.resolvers = {
    cft: (argument, config) => __awaiter(this, void 0, void 0, function* () {
        if (!AWS.config.region) {
            AWS.config.update({ region: config.awsRegion });
        }
        const cft = new AWS.CloudFormation();
        const parsedArgument = argument.split('.', 2);
        let stack;
        try {
            stack = yield cft.describeStacks({ StackName: parsedArgument[0] }).promise();
        }
        catch (e) {
            console.warn(`Could not get info for stack with name ${parsedArgument[0]} when parsing cft reference ${argument}: ${e}`);
            return undefined;
        }
        if (stack.Stacks.length == 0) {
            console.warn(`Could not locate stack with name ${parsedArgument[0]} when parsing cft reference ${argument}`);
            return undefined;
        }
        for (const output of stack.Stacks[0].Outputs) {
            if (output.OutputKey === parsedArgument[1]) {
                return output.OutputValue;
            }
        }
        console.warn(`Could not locate output ${parsedArgument[1]} of stack ${parsedArgument[0]}`);
        return undefined;
    }),
    env: (argument) => __awaiter(this, void 0, void 0, function* () {
        if (!process.env[argument]) {
            console.warn(`Environment variable ${argument} is undefined`);
        }
        return process.env[argument];
    }),
    constant: (argument) => __awaiter(this, void 0, void 0, function* () {
        return argument;
    }),
    cred: (argument, config) => __awaiter(this, void 0, void 0, function* () {
        const credstash = new Credstash({ awsOpts: { region: config.awsRegion } });
        const promisified = bluebird_1.promisify(credstash.getSecret, { context: credstash });
        return promisified({ name: argument }).catch((error) => {
            console.warn(`Could not load value ${argument} from credstash: ${error}`);
            return undefined;
        });
    }),
    asm: (argument) => __awaiter(this, void 0, void 0, function* () {
        const params = argument.split('.');
        const [secretId, ...jsonMappings] = params;
        if (!secretId) {
            console.warn('No id provided to aws secret manager resolver');
            return undefined;
        }
        const client = new AWS.SecretsManager();
        try {
            const { SecretString } = yield client
                .getSecretValue({ SecretId: secretId })
                .promise();
            if (jsonMappings.length) {
                const parseJson = JSON.parse(SecretString);
                const lookupSecretValue = utils_1.accessNestedObject(parseJson, jsonMappings);
                if (!lookupSecretValue) {
                    console.warn(`No aws secret manager value found for ${secretId}`);
                    return undefined;
                }
                return lookupSecretValue;
            }
            return SecretString;
        }
        catch (e) {
            console.warn(e.message);
            return undefined;
        }
    })
};
//# sourceMappingURL=resolvers.js.map